name: Build QB64-PE from source (Linux)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read

env:
  APP_NAME: MyProgram
  ENTRY_BAS: src/main.bas

jobs:
  build-qb64pe-src:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # (Often preinstalled, but harmless to ensure basics are present)
      - name: Install build prerequisites
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            build-essential curl ca-certificates unzip tar \
            libx11-dev libxext-dev libxrender-dev libxrandr-dev libxi-dev \
            libxinerama-dev libxcursor-dev \
            libgl1-mesa-dev libglu1-mesa-dev \
            libasound2-dev libpulse-dev \
            libpng-dev zlib1g-dev

      - name: Download QB64-PE Linux source tarball
        env:
          API_URL: https://api.github.com/repos/QB64-Phoenix-Edition/QB64pe/releases/latest
        run: |
          set -euo pipefail
          rel="$(curl -fsSL "$API_URL")"

          # Pick a *source* archive, not prebuilt; avoid anything with 'lnx' without 'src'
          url="$(printf '%s\n' "$rel" \
            | grep -Eo '"browser_download_url": *"[^"]+"' \
            | sed -E 's/.*"([^"]+)".*/\1/' \
            | grep -Ei 'qb64pe_.*(src|source).*\.(tar\.gz|zip)$' \
            | head -n1 || true)"

          [ -n "${url:-}" ] || { echo "No Linux *source* asset found."; exit 1; }

          name="$(basename "$url")"
          curl -fsSL "$url" -o "$name"

          # Extract to the workspace root and detect top-level folder name
          case "$name" in
            *.zip)
              unzip -q "$name"
              ;;
            *.tar.gz)
              tar -xzf "$name"
              ;;
          esac

          # Detect the top-level extracted directory (portable)
          toplevel="$(
            case "$name" in
              *.zip) unzip -Z1 "$name" | head -1 | cut -d/ -f1 ;;
              *.tar.gz) tar -tzf "$name" | head -1 | cut -d/ -f1 ;;
            esac
          )"

          [ -n "$toplevel" ] || { echo "Failed to detect extracted top-level dir"; exit 1; }
          echo "SRC_TOP=$toplevel" >> "$GITHUB_ENV"

      - name: Build QB64-PE (setup_lnx.sh)
        run: |
          set -euo pipefail
          cd "$SRC_TOP"

          # The setup script lives in the source root for QB64-PE
          if [ ! -x "./setup_lnx.sh" ]; then
            echo "setup_lnx.sh not found in $PWD. Contents:"
            find . -maxdepth 2 -type f | sed 's/^/  /'
            exit 1
          fi

          # Build QB64-PE from source
          ./setup_lnx.sh

          # Locate the freshly built qb64pe binary and its folder
          qb_path="$(find . -type f -name qb64pe -perm -111 | head -n1 || true)"
          [ -n "$qb_path" ] || { echo "qb64pe binary not found after build"; exit 1; }

          qb_dir="$(dirname "$qb_path")"
          echo "QB_DIR=$qb_dir" >> "$GITHUB_ENV"
          echo "QB_BIN=$qb_path" >> "$GITHUB_ENV"

      - name: Upload built QB64-PE (for later reuse)
        uses: actions/upload-artifact@v4
        with:
          name: qb64pe-linux-built
          path: ${{ env.SRC_TOP }}/${{ env.QB_DIR }}

      # -------- Optional: compile your BASIC entry if present ----------
      - name: Compile your BASIC (if src/main.bas exists)
        if: ${{ hashFiles(env.ENTRY_BAS) != '' }}
        run: |
          set -euo pipefail
          [ -x "${QB_BIN:?}" ] || { echo "QB_BIN not executable"; exit 1; }
          [ -f "${ENTRY_BAS:?}" ] || { echo "ENTRY_BAS not found: $ENTRY_BAS"; exit 1; }
          mkdir -p build
          "${QB_BIN}" -x "$ENTRY_BAS" -o "build/${APP_NAME}-linux-x64"

      - name: Upload compiled app (if built)
        if: ${{ hashFiles('build/*') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-linux-x64
          path: build/${{ env.APP_NAME }}-linux-x64
